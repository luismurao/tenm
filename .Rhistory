adj_cellsL
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
adj_cellsL
ids_dups <- unique(unlist(adj_cellsL))
ids_dups
which(no_dups %in% ids_dups)
no_dups <- seq_len(nrow(data))
no_dups
ids_dups
which(no_dups %in% ids_dups)
ids_dups <- which(no_dups %in% ids_dups)
ids_dups
if(length(ids_dups)>0L){
no_dups <- no_dups[-ids_dups]
}
dat3 <- dat2[no_dups,-ncol(dat2)]
dat3
dat2$cellid <- cellids2
cellids2 <- sort(cellids2)
adj_cells <- terra::adjacent(x = raster_mask,cells=cellids2,
directions = ngMat,
pairs = TRUE)
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
ids_dups <- unique(unlist(adj_cellsL))
no_dups <- seq_len(nrow(data))
no_dups <- which(no_dups %in% ids_dups)
no_dups
if(length(ids_dups)>0L){
no_dups <- no_dups[-ids_dups]
}
dat3 <- dat2[no_dups,-ncol(dat2)]
dat3
no_dups
dat2
data =abronia
longitude = "decimalLongitude"
latitude = "decimalLatitude"
threshold = terra::res(tenm_mask)[1]
by_mask = TRUE
raster_mask = tenm_mask
n_ngbs = 1
data <- data[!is.na(data[,longitude]),]
data
dat_sp <- sf::st_as_sf(data,coords=c(longitude,latitude),
crs=sf::st_crs(raster_mask))
nbase <- 2*n_ngbs+1
ngMat <- base::matrix(rep(1,nbase*nbase),
ncol =nbase,byrow = T )
ngMat[n_ngbs+1,n_ngbs+1] <- 0
cellids <- terra::cellFromXY(raster_mask, sf::st_coordinates(dat_sp))
ids_nodup <- which(!duplicated (cellids))
ids_nodup
cellids
ids_nodup <- which(!duplicated (cellids))
ids_nodup
cellids2 <- cellids[ids_nodup]
cellids2
#dat2 <- dat_sp@data [ids_nodup,]
coo <- data.frame(sf::st_coordinates(dat_sp))
names(coo) <- c(longitude,latitude)
dat2 <- sf::st_drop_geometry(dat_sp)
dat2 <- data.frame(coo,dat2)
dat2
if(ncol(dat2)>=4){
dat2 <- dat2[ids_nodup,c(3,1,2,(4:ncol(dat2)))]
} else{
dat2 <- dat2[ids_nodup,c(3,1,2)]
}
dat2
dat2$cellid <- cellids2
dat2
cellids2 <- sort(cellids2)
adj_cells <- terra::adjacent(x = raster_mask,cells=cellids2,
directions = ngMat,
pairs = TRUE)
adj_cells
cellids2
ids_dups <- unique(unlist(adj_cellsL))
ids_dups
cellids2
cellids2 %in% ids_dups
ids_dups
which(cellids2 %in% ids_dups)
cellids2[which(cellids2 %in% ids_dups)]
cellids2
adj_cellsL
ids_dups <- unique(unlist(adj_cellsL))
ids_dups
ids_dups
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
adj_cellsL
cellids2
?terra::adjacent
adj_cells <- terra::adjacent(x = raster_mask,cells=cellids2,
directions = ngMat,
pairs = TRUE)
adj_cells
which(adj_cells[,2] %in% cellids2)
occ_adj_id <- which(adj_cells[,2] %in% cellids2)
if(length(occ_adj_id)>0L){
adj_cells <- adj_cells[occ_adj_id,]
}
adj_cells
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
adj_cellsL
ids_dups <- unique(unlist(adj_cellsL))
ids_dups
adj_cells
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
adj_cellsL
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
targets <- names(adj_cellsL)
targets
keep <- rep(NA,length(targets ))
keep
j <- 1
focal <- targets[i]
focal
j <- 1
i=1
focal <- targets[i]
focal
focal %in% names(adj_cellsL)
vecinos <- as.character(adj_cellsL [[focal]])
vecinos
id_bas <- which(names(adj_cellsL) %in% vecinos)
id_bas
if(length(id_bas)>0L) adj_cellsL <- adj_cellsL[- id_bas]
adj_cellsL <- split(adj_cells[,2], adj_cells[,1])
targets <- names(adj_cellsL)
keep <- rep(NA,length(targets ))
j <- 1
for(i in seq_along(targets)){
focal <- targets[i]
if(focal %in% names(adj_cellsL)){
vecinos <- as.character(adj_cellsL [[focal]])
id_bas <- which(names(adj_cellsL) %in% vecinos)
if(length(id_bas)>0L) adj_cellsL <- adj_cellsL[- id_bas]
keep[j] <- as.numeric(focal)
j <- j+1
}
}
ids_nodup2 <- which(dat2$cellid %in% keep)
ids_nodup2
dat3 <- dat2[ids_nodup2,-ncol(dat2)]
dat3
library(tenm)
pkgdown::build_site()
library(tenm)
library(tenm)
library(tenm)
library(tenm)
pkgdown::build_site()
library(tenm)
library(tenm)
library(tenm)
install.packages("colorspace")
library(colorspace)
hclwizard()
install.packages("shinyjs")
hclwizard()
hclwizard()
hclwizard()
hclwizard()
library(tenm)
library(pkgdown)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
devtools::install_github("luismurao/tenm")
colorss <- hcl.colors(length(unique(abronia$year)))
par(mar=c(4,4,2,2))
plot(abronia$decimalLongitude, abronia$decimalLatitude,
col=colorss,pch=19, cex=0.75,
xlab="Longitude",ylab="Latitude",xlim=c(-98.35,-96.7))
legend("bottomleft",legend = sort(unique(abronia$year))[1:20],
cex=0.85,pt.cex = 1,bty = "n",
pch=19,col =colorss[1:20])
legend("bottomright",
legend = sort(unique(abronia$year))[21:length(unique(abronia$year))],
cex=0.85,pt.cex = 1,bty = "n",
pch=19,col =colorss[21:length(unique(abronia$year))])
# Load a modeling layer
tempora_layers_dir <- system.file("extdata/bio",package = "tenm")
tenm_mask <- terra::rast(file.path(tempora_layers_dir,"1939/bio_01.tif"))
ab_1 <- tenm::clean_dup(data =abronia,
longitude = "decimalLongitude",
latitude = "decimalLatitude",
threshold = terra::res(tenm_mask),
by_mask = FALSE,
raster_mask = NULL)
tidyr::as_tibble(ab_1)
ab_by_mask <- tenm::clean_dup(data =abronia,
longitude = "decimalLongitude",
latitude = "decimalLatitude",
threshold = terra::res(tenm_mask),
by_mask = TRUE,
raster_mask = tenm_mask)
tidyr::as_tibble(ab_by_mask)
tempora_layers_dir <- system.file("extdata/bio",package = "tenm")
print(tempora_layers_dir)
#> [1] "/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library/tenm/extdata/bio"
data("abronia")
tempora_layers_dir <- system.file("extdata/bio",package = "tenm")
abt <- tenm::sp_temporal_data(occs = abronia,
longitude = "decimalLongitude",
latitude = "decimalLatitude",
sp_date_var = "year",
occ_date_format="y",
layers_date_format= "y",
layers_by_date_dir = tempora_layers_dir,
layers_ext="*.tif$")
# Clean duplicates using a raster mask
abtc <- tenm::clean_dup_by_date(this_species = abt,
by_mask = TRUE,
threshold = terra::res(tenm_mask)[1],
raster_mask = tenm_mask[1],
n_ngbs = 0)
# Check number of records
head(tidyr::as_tibble(abtc$temporal_df))
colors1 <- hcl.colors(length(unique(ab_1$year)))
par(mar=c(4,4,2,2),mfrow=c(1,2))
plot(ab_1$decimalLongitude, ab_1$decimalLatitude,
col=colors1,pch=19, cex=0.75,
xlab="Longitude",ylab="Latitude",xlim=c(-98.35,-96.7))
legend("bottomleft",legend = sort(unique(ab_1$year))[1:10],
cex=0.85,pt.cex = 1,bty = "n",
pch=19,col =colors1[1:10])
colors2 <- hcl.colors(length(unique(abtc$temporal_df$year)))
plot(abtc$temporal_df$decimalLongitude, abtc$temporal_df$decimalLatitude,
col=colors2,pch=19, cex=0.75,
xlab="Longitude",ylab="Latitude",xlim=c(-98.35,-96.7))
legend("bottomleft",legend = sort(unique(abtc$temporal_df$year))[1:16],
cex=0.85,pt.cex = 1,bty = "n",
pch=19,col =colors2[1:16])
legend("bottomright",
legend = sort(unique(abronia$year))[17:length(unique(abtc$temporal_df$year))],
cex=0.85,pt.cex = 1,bty = "n",
pch=19,col =colors2[17:length(unique(abtc$temporal_df$year))])
future::plan("multisession",workers=2)
abex <- tenm::ex_by_date(this_species = abtc,
train_prop=0.7)
future::plan("sequential")
library(tenm)
devtools::build_manual()
install.packages("spdep")
spdep::sp.correlogram()
?spdep::sp.correlogram(
)
?bamm::bam_clusters()
set.seed(891)
model_path <- system.file("extdata/Lepus_californicus_cont.tif",
package = "bamm")
model <- raster::raster(model_path)
model <- model > 0.7
clusterin <- bamm::bam_clusters(model,ngbs=1,plot_model=TRUE)
raster::plot(clusterin@raster_map)
clusterin@interactive_map
plot(model)
raster::plot(clusterin@raster_map)
?ntbox::correlation_finder
library(tenm)
pkgdown::build_site()
library(tenm)
library(tenm)
library(tenm)
library(tenm)
pkgdown::build_site()
library(tenm)
pkgdown::build_site()
library(tenm)
?ellipsoid_selection
?tenm_selection
library(tenm)
data("abronia")
tempora_layers_dir <- system.file("extdata/bio",package = "tenm")
abt <- tenm::sp_temporal_data(occs = abronia,
longitude = "decimalLongitude",
latitude = "decimalLatitude",
sp_date_var = "year",
occ_date_format="y",
layers_date_format= "y",
layers_by_date_dir = tempora_layers_dir,
layers_ext="*.tif$")
abtc <- tenm::clean_dup_by_date(abt,threshold = 10/60)
future::plan("multisession",workers=2)
abex <- tenm::ex_by_date(this_species = abtc,
train_prop=0.7)
abbg <- tenm::bg_by_date(abex,
buffer_ngbs=10,n_bg=50000)
future::plan("sequential")
varcorrs <- tenm::correlation_finder(environmental_data = abex$env_data[,-ncol(abex$env_data)],
method = "spearman",
threshold = 0.8,
verbose = FALSE)
vars2fit <- varcorrs$descriptors
mod_sel <- tenm::tenm_selection(this_species = abbg,
omr_criteria =0.1,
ellipsoid_level=0.975,
vars2fit = vars2fit,
nvars_to_fit=c(2,3,4,5,6,7),
proc = T,
RandomPercent = 50,
NoOfIteration=1000,
parallel=TRUE,
n_cores=20)
# Project potential distribution using bioclimatic layers for 1970-2000
# period.
layers_70_00_dir <- system.file("extdata/bio_1970_2000",package = "tenm")
suit_1970_2000 <- predict(mod_sel,model_variables = NULL,
layers_path = layers_70_00_dir,
layers_ext = ".tif$")
mod_sel
suit_1970_2000 <- predict(mod_sel,model_variables = c("bio_01","bio_04","bio_07"),
layers_path = layers_70_00_dir,
layers_ext = ".tif$")
suit_1970_2000 <- predict(mod_sel,model_variables = c("bio_01","bio_04","bio_07"),
layers_path = layers_70_00_dir,
layers_ext = ".tif$",output="mahalanobis")
object = mod_sel
model_variables = c("bio_01","bio_04","bio_07")
layers_path = layers_70_00_dir
layers_ext = ".tif$"
output="mahalanobis"
mod_table <- object$mods_table
model_vars <- stringr::str_split(mod_table$fitted_vars,",")
#layers_in <- which(!layers_path %in% unique(object$temporal_df$layers_path))
#if(length(layers_in)>0){
# stop(paste("Not a valid path:",layers_path[layers_in],
#             "please provide a valid path"))
#}
if(is.null(model_variables)){
message(paste0("No selected variables. Using the first model in mods_table"))
mod_vars <- model_vars[[1]]
} else{
mod_vars <- model_variables
idvars <- which(!mod_vars %in% names(object$env_bg))
if(length(idvars)>0L){
stop(paste("Not valid variable names:",model_vars[idvars],
"please provide valid variable names"))
}
}
#----------------------------------------------------------
# Fit ellipsoid model in E-space
trian_ids <- object$temporal_df$trian_test== "Train"
env_data <- object$temporal_df[trian_ids,mod_vars]
env_data <- stats::na.omit(env_data)
mod <- tenm::cov_center(env_data,mve = mve,
level = level,vars = mod_vars)
mve=T
mod <- tenm::cov_center(env_data,mve = mve,
level = level,vars = mod_vars)
level=0.975
mod <- tenm::cov_center(env_data,mve = mve,
level = level,vars = mod_vars)
projmods <- tenm::ellipsoid_projection(envlayers = terra::rast(layers),
centroid = mod$centroid,
covar = mod$covariance,
level = 0.9999,
plot = TRUE,size = 2,
output = output)
layers
layers = NULL
pb <- utils::txtProgressBar(min = 0,max = length(layers_path),style = 3)
layers_path
x=1
lnames <- list.files(layers_path[x],pattern = layers_ext)
lnames
lanames <- gsub(layers_ext,"",lnames)
lanames
var_ids <- which(lanames %in% mod_vars)
var_ids
layer2proj <- list.files(layers_path[x],full.names = T,
pattern = layers_ext)[var_ids]
layer2proj
slayers <- terra::rast(layer2proj)
suitmod <- tenm::ellipsoid_projection(envlayers = slayers,
centroid = mod$centroid,
covar = mod$covariance,
level = 0.9999,
plot = TRUE,
size = 2,
output = output)
envlayers = slayers
centroid = mod$centroid
covar = mod$covariance
level = 0.9999
plot = TRUE
size = 2
output = output
if(methods::is(envlayers, "SpatRaster")){
suitRaster <- envlayers[[1]]
names(suitRaster) <- "Suitability"
nonaids <- which(!is.na(suitRaster[]))
env_vars <- 1:terra::nlyr(envlayers) |> purrr::map_dfc(function(x){
val <- envlayers[[x]][]
dfv <- data.frame(val[nonaids])
names(dfv) <- names(envlayers[[x]])
return(dfv)
})
}
# Calculating distance to the centroid
mahalanobisD <- stats::mahalanobis(env_vars,
center = centroid,
cov = covar)
suit <- function( mahalanobisD){
expo <- exp(-0.5* mahalanobisD)
return(expo)
}
output
# Computing the suitabilities
if(output =="suitability"){
suits <- suit( mahalanobisD)
} else if(output == "mahalanobis"){
suits <- mahalanobisD
}
rm(list = c("mahalanobisD"))
suitVals <- rep(NA,terra::ncell(envlayers[[1]]))
suitVals[nonaids] <- suits
suitRaster[] <- suitVals
plotsuitRaster
plot(suitRaster)
data1 <- env_vars
dfd <- dim(data1)[1] - 1
dfn <- dim(data1)[2] - 1
ellips_E  <- rgl::ellipse3d(covar,centre = centroid,level = 0.99)
if(dfd > 50000)
np <- 50000
else
if(dfd > 50000)
np <- 50000
else
dfd > 50000
np <- dim(data1)[1]
toSam <- sample(1:length(data1[,1]),np)
data1 <- data1[toSam,]
if(output == "suitability"){
suits2 <- suits[toSam]
} else if(output == "mahalanobis"){
suits2 <- suit(data1)
}
suits2
suit <- function( mahalanobisD){
expo <- exp(-0.5* mahalanobisD)
return(expo)
}
suits2 <- suit(data1)
suits2
suit(data1)
suits2 <- suit(suits[toSam])
suits2
library(tenm)
ntbox::biaslayer()
ntbox::biaslayer
?ntbox::biaslayer
?ovellip::
?ovellip
library(overllip)
?overllip::stack_overlap()
# Check spelling
# usethis::use_spell_check()
spelling::spell_check_package()
?ntbox::bin_model
model_p <- system.file("extdata/ambystoma_model.tif",
package = "ntbox")
model <- raster::raster(model_p)
data_p <- system.file("extdata/ambystoma_validation.csv",
package = "ntbox")
data <- read.csv(data_p)
occs <- data[which(data$presence_absence==1),]
occs
binary <- bin_model(model,occs,percent = 5)
binary
binary <- bin_model(model,occs,percent = 5)
binary <- ntbox::bin_model(model,occs,percent = 5)
data <- read.csv(data_p)
occs <- data[which(data$presence_absence==1),]
binary <- ntbox::bin_model(model,occs,percent = 5)
binary <- ntbox::bin_model(model,occs[,1:2],percent = 5)
binary
ntbox::bin_model
plot(model)
raster::extract(model,occs[,1:2])
sort(na.omit(raster::extract(model,occs[,1:2])))
suits <- sort(na.omit(raster::extract(model,occs[,1:2])))
fiveperID <- ceiling(length(suits)*0.05)
fiveperID
umbralID <- ceiling(length(suits)*0.05)
umbral <- suits[umbralID]
umbral
#-------------------------------------------------------------------------------
# Calculo del umbral
#-------------------------------------------------------------------------------
# Primero se extraen los valores ordenados de idoneidad
suits <- sort(na.omit(raster::extract(model,occs[,1:2])))
umbralID <- ceiling(length(suits)*0.05)
# Binarizando el mapa
binmod <- model > umbral
install.packages("bamm")
?bamm::permute_pam
pam <- matrix(rbinom(1000000,1,0.3),nrow = 1000,ncol = 1000)
ppam <- bamm::permute_pam(m = pam,niter = NULL,as_sparse = FALSE)
ppam
pam <- matrix(rbinom(10000000000,1,0.3),nrow = 100000,ncol = 100000)
dim(pam)
ppam <- bamm::permute_pam(m = pam,niter = NULL,as_sparse = FALSE)
gc()
gc()
# Check if matrices are different
all(pam == ppam)
gc()
all(Matrix::rowSums(pam) == Matrix::rowSums(ppam))
